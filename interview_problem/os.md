# Operating System

## 目录
- [大小端](#大小端)
- [TLB](#TLB)
- [文件共享（多个线程打开同一个文件）](#文件共-多个线程打开同一个文件）)
- [同步](#同步) 
- [进程间通信方式](#进程间通信方式)
- [linux 下 pthread库（POSIX）](#linux-下-pthread库（POSIX）)
- [匿名管道特性](#匿名管道特性)
- [息队列特性（ipcs -q 查看）](#息队列特-（ipcs--q-查看）) 
- [多级寻址](#多级寻址)
- [PCB](#PCB)
- [锁](#锁)
---

[操作系统清华向勇陈渝版笔记](https://blog.csdn.net/github_36487770/article/details/60144610)

### 进程和线程的区别
#### 相同点
1. 子进程(子线程)的调度一般与父进程(父线程)平等竞争（其实在Linux内核2.4版以前，线程的实现和管理方式就是完全按照进程方式实现的。在2.6版内核以后才有了单独的线程实现。）

#### 实现方式的差异
1. 进程是资源分配的基本单位，线程是调度的基本单位。
2. 进程的个体间是完全独立的，而线程间是彼此依存的。多进程环境中，任何一个进程的终止，不会影响到其他进程。而多线程环境中，父线程终止，全部子线程被迫终止(没有了资源)。而任何一个子线程终止一般不会影响其他线程，除非子线程执行了exit()系统调用。任何一个子线程执行exit()，全部线程同时灭亡。
3. 而且，进程间采用的通信方式要么需要切换内核上下文，要么要与外设访问(有名管道，文件)。所以速度会比较慢。而线程采用自己特有的通信方式的话，基本都在自己的进程空间内完成，不存在切换，所以通信速度会较快。
4. 回收。进程的ID为pid_t类型，实际为一个int型的变量(也就是说是有限的)。每一个存储进程信息的节点也都保存着自己的PID。需要管理该进程时就通过这个ID来实现(比如发送信号)。当子进程结束要回收时(子进程调用exit()退出或代码执行完)，需要通过wait()系统调用来进行，未回收的消亡进程会成为僵尸进程，其进程实体已经不复存在，但会虚占PID资源，因此回收是有必要的。线程的ID是一个long型变量：它的范围大得多，管理方式也不一样。线程ID一般在本进程空间内作用就可以了，当然系统在管理线程时也需要记录其信息。其方式是，在内核创建一个内核态线程与之对应，也就是说每一个用户创建的线程都有一个内核态线程对应。但这种对应关系不是一对一，而是多对一的关系，也就是一个内核态线程可以对应着多个用户级线程。

从系统实现角度讲，进程的实现是调用fork系统调用：

pid_t fork(void);

线程的实现是调用clone系统调用：

int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...

/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */

);

vfork() 。这也是一个系统调用，用来创建一个新的进程。它创建的进程并不复制父进程的资源空间，而是共享，也就说实际上vfork实现的是一个接近线程的实体，只是以进程方式来管理它。并且，vfork()的子进程与父进程的运行时间是确定的：子进程“结束”后父进程才运行。


一般采用vfork()的子进程，都会紧接着执行execv启动一个全新的进程，该进程的进程空间与父进程完全独立不相干，所以不需要复制父进程资源空间。此时，execv返回时父进程就认为子进程“结束”了，自己开始运行。实际上子进程继续在一个完全独立的空间运行着。举个例子，比如在一个聊天程序中，弹出了一个视频播放器。你说视频播放器要继承你的聊天程序的进程空间的资源干嘛？莫非视频播放器想要窥探你的聊天隐私不成？

#### 多任务
比如多任务的TCP程序的服务端，父进程执行accept()一个客户端连接请求之后会返回一个新建立的连接的描述符DES，此时如果fork()一个子进程，将DES带入到子进程空间去处理该连接的请求，父进程继续accept等待别的客户端连接请求，这样设计非常简练，而且父进程可以用同一变量(val)保存accept()的返回值，因为子进程会复制val到自己空间，父进程再覆盖此前的值不影响子进程工作。但是如果换成多线程，父线程就不能复用一个变量val多次执行accept()了。因为子线程没有复制val的存储空间，而是使用父线程的。改进的办法是子线程立马复制val的值在自己的栈区，但父线程必须保证子线程复制动作完成之后再执行新的accept()。

这里引述一个知名的面试问题：多进程的TCP服务端，能否互换fork()与accept()的位置？

#### 为什么要通信
多进程环境间完全独立，要实现通信的话就得采用进程间的通信方式，它们通常都是耗时间的。而线程则不用任何手段数据就是共享的。

进程间的通信方式有这样几种：

A.共享内存    B.消息队列    C.信号量    D.有名管道    E.无名管道    F.信号

G.文件        H.socket

线程间的通信方式上述进程间的方式都可沿用，且还有自己独特的几种：

A.互斥量      B.自旋锁      C.条件变量  D.读写锁      E.线程信号

G.全局变量


### 进程调度算法

#### 先来先服务 （FCFS，first come first served） 
1. 在所有调度算法中，最简单的是非抢占式的FCFS算法。 
2. 算法原理：进程按照它们请求CPU的顺序使用CPU.就像你买东西去排队，谁第一个排，谁就先被执行，在它执行的过程中，不会中断它。当其他人也想进入内存被执行，就要排队等着，如果在执行过程中出现一些事，他现在不想排队了，下一个排队的就补上。此时如果他又想排队了，只能站到队尾去。 
3. 算法优点：易于理解且实现简单，只需要一个队列(FIFO)，且相当公平 
4. 算法缺点：比较有利于长进程，而不利于短进程，有利于CPU 繁忙的进程，而不利于I/O 繁忙的进程

#### 最短作业优先（SJF, Shortest Job First） 
1. 短作业优先（SJF, Shortest Job First）又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。 
3. 算法原理：对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程。 
4. 算法优点：相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。 
5. 算法缺点：对长进程非常不利，可能长时间得不到执行，且未能依据进程的紧迫程度来划分执行的优先级，以及难以准确估计进程的执行时间，从而影响调度性能。

#### 最高响应比优先法(HRRN，Highest Response Ratio Next) 
1. 最高响应比优先法(HRRN，Highest Response Ratio Next)是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。 
2. 算法原理：响应比R定义如下： R =(W+T)/T = 1+W/T 
其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。 
3. 算法优点：由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRRN方式时其吞吐量将小于采用SJF 法时的吞吐量。 
4. 算法缺点：由于每次调度前要计算响应比，系统开销也要相应增加。

#### 时间片轮转算法（RR，Round-Robin） 
1. 该算法采用剥夺策略。时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。 
2. 算法原理：让就绪进程以FCFS 的方式按时间片轮流使用CPU 的调度方式，即将系统中所有的就绪进程按照FCFS 原则，排成一个队列，每次调度时将CPU 分派给队首进程，让其执行一个时间片，时间片的长度从几个ms 到几百ms。在一个时间片结束时，发生时钟中断，调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）。 
3. 算法优点：时间片轮转调度算法的特点是简单易行、平均响应时间短。 
4. 算法缺点：不利于处理紧急作业。在时间片轮转算法中，时间片的大小对系统性能的影响很大，因此时间片的大小应选择恰当 
怎样确定时间片的大小：

时间片大小的确定 
1. 系统对响应时间的要求 
2. 就绪队列中进程的数目 
3. 系统的处理能力

#### 多级反馈队列(Multilevel Feedback Queue) 
多级反馈队列调度算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。 

多级反馈队列调度算法描述： 
　　1. 进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。 
　　2. 首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。 
　　3. 对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。 
　　4. 在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。 
　　在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。
### 大小端
![](http://img.blog.csdn.net/20170906230027562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg4OTYxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

C++代码验证大端还是小端存储
```
#include <iostream>

using namespace std;
int main()
{
    int nNum = 0x12345678;
    char chData = *(char*)(&nNum);

    if (chData == 0x12)
    {
        cout << "big" << endl;
    }
    else
    {
        cout << "small" << endl;
    }

    system("PAUSE");

    return 0;
}

```
### PCB

为了描述和管理进程的运行，在OS的核心专门定义了一个数据结构----进程控制块（PCB）

其作为进程实体的一部分，记录了OS所需的，用于描述进程当前的情况以及进程运行的消息。

作用：使一个在多道程序环境下不能独立运行的程序成为一个能够独立运行的基本单位，一个能与其他进程并发执行的程序。

1：作为独立运行基本单位的标志。系统是通过PCB感知进程的存在。

2:能实现间断性运行的方式。多到程序运行的情况下程序是走走停停，间断运行的，当程序移交CPU的时候必须保留现场，调用时要恢复现场，PCB中保留了中断程序的现场信息，

3：提供进程调度所需的信息：

4：提供进程调度所需的信息；PCB中提供了进程的状态信息，还有其它信息任如（进程的优先级，进程的等待时间，以及和执行时间）

5：实现与其他进程的同步与信息：进程同步机制是用于实现各进程间的协调运行，采用信号量机制时，要求每个进程都设置相应的同于同步的信号量。在PCB中还具有实现进程通信区域或通信队列指针等。

进程控制块中的信息

1：进程标识符（PID）：用于唯一标识一个进程一个进程通常有两种标识符1：外部与内部标识符。

2：处理机状态：处理机的状态信息，也称为处理机的上下文，当进程切换时，处理机的状态信息必须保存在相应的PCB中，以便在该进程重新执行时从断点处开始。

3：进程调度信息：在OS进行进程调度的时候，必须了解进程的状态以及进程的调度信息。

如（进程的状态，进程的优先级，其他消息（进程调度算法），事件（引起阻塞原因））

4：进程的控制信息：包括1：程序和数据地址，2：进程同步和通信机制，3：资源抢清单4：连接指针。


线程有自己的TCB，thread control block, 只负责这条流程的信息，包括PC程序计数器，SP堆栈，State状态，和寄存器。有不同的控制流，需要不同的寄存器来表示控制流的执行状态，每个线程有独立的这些信息，但共享一个资源。

线程=进程-共享资源 

### TLB
Translation Lookaside Buffer.
![TLB_image](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=d92dd174afd3fd1f2204aa6851274e7a/ac6eddc451da81cb627dc1975566d016082431d4.jpg "TLB")
X86保护模式下的寻址方式：段式逻辑地址—〉线形地址—〉页式地址；
页式地址=页面起始地址+页内偏移地址；
对应于虚拟地址：叫page（页面）；对应于物理地址：叫frame（页框）；
X86体系的系统内存里存放了两级页表，第一级页表称为页目录，第二级称为页表。
TLB和CPU里的一级、二级缓存之间不存在本质的区别，只不过前者缓存页表数据，而后两个缓存实际数据。

### 文件共享（多个线程打开同一个文件）
！[file_share_image](http://blog.chinaunix.net/attachment/201109/18/24585858_13163316796P22.jpg)
函数调用fork后产生的父子进程中，它们共享相同的i或v节点和同一个文件表项。



### 同步
线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。

用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。

内核模式下的方法有：事件，信号量，互斥量。

1. 临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
2. 互斥量:为协调共同对一个共享资源的单独访问而设计的。 
3. 信号量:为控制一个具有有限数量用户资源而设计。 
4. 事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

## [进程间通信方式](http://www.cnblogs.com/lenomirei/p/5636339.html)

（1）管道（pipe）及有名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。

（2）信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。

（3）消息队列（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。

（4）共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。

（5）信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。

（6）套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。


## linux 下 pthread库（POSIX）
```
int pthread_create(pthread_t *tidp, //第一个参数为指向线程标识符的指针。
    const pthread_attr_t *attr,    //第二个参数用来设置线程属性。
    (void*)(*start_rtn)(void*), //第三个参数是线程运行函数的起始地址。
    void *arg    //最后一个参数是运行函数的参数
    );

//线程通过调用pthread_exit函数终止执行
void pthread_exit(void* retval);

//函数pthread_join用来等待一个线程的结束,线程间同步的操作,阻塞函数
int pthread_join(pthread_t thread, void **retval);

```
互斥锁：等价于二元信号量

- pthread_mutex_init初始化一个锁
- pthread_mutex_destory销毁互斥锁
- pthread_mutex_lock原子方式给加锁，如果自身线程对自身加锁的锁再次加锁，则死锁；其余线程加锁则不会死锁，但会阻塞。
- pthread_mutex_trylock非阻塞加锁
- pthread_mutex_unlock原子操作方式来解锁

``` 
pthread_mutex_t mutex;
pthread_mutex_init(&mutex, NULL);
pthread_mutex_lock(&mutex);
pthread_mutex_unlock(&mutex);
``` 

同步步骤：信号量 头文件<semaphore.h>

- sem_init函数用于初始化一个未命名的信号量
- sem_destory函数用于销毁信号量
- sem_wait函数以原子操作的方式将信号量的值减1，如果信号量的值为0，则阻塞。
- sem_trywait上面的非阻塞版本，如果信号量为0，立即返回-1，并设置errno为EAGIN
- sem_post将信号量的值加1


### 匿名管道特性

1. 管道是依赖于文件系统的，创建好管道之后，一定要关闭不使用的读写端
2. 只有父子进程才可以使用管道通信，也就是所谓的有血缘关系的进程进行进程间通信。（匿名管道独有）
3. 管道是基于数据流的，面向字节流！（后面会提到消息队列是面向数据块的，对比来看会好懂一些）
4. 管道只能称之为单向数据通信，连半双工都算不上
5. 同步与互斥问题不需要考虑了，管道已经考虑了
6. 当父子进程退出的时候，管道的生命周期就结束了，也就是说管道的生命周期就是进程
7. 最后的最后，来一个管道最大的缺点，管道是基于文件系统的！所以不管是读还是写，都要求访问磁盘进行I/O操作，I/O的速度你懂得，特别慢，所以不适合做多个client的结构，不然会很慢
wo 
### 消息队列特性（ipcs -q 查看）
1. 匿名管道是跟随进程的，消息队列是跟随内核的，也就是说进程结束之后，匿名管道就死了，但是消息队列还会存在（除非显示调用函数销毁）
1. 管道是文件，存放在磁盘上，访问速度慢，消息队列是数据结构，存放在内存，访问速度快
1. 管道是数据流式存取，消息队列是数据块式存取


### 多级寻址
https://blog.csdn.net/li_boxue/article/details/48448757
某次进程切换过程中的寻址的整个过程。 
1． schedule()在内核空间，需要获取到切换到的进程的结构体task_struct以及mm_struct，假设已经拿到其地址值。由于这个结构体在内核空间，因此全局描述符表寄存器gdtr不需要改变，内核向段寄存器中写入段选择符，向某个通用寄存器写入偏移量，调用一条内存加载汇编指令加载该值，这时分段单元先从内存的全局段描述符表中加载段描述符，找到段基址，加上偏移量构成线性地址。 
2． 接下来分页单元对该线性地址分为三部分：页目录、页表、偏移量。通过CR3寄存器的值读一次内存加载页目录表，找到页目录项，再读一次内存加载页表，找到页表项，最后读一次内存把真正需要的值返回给CPU。 
3． 此时读到的值仅是为了写入CR3寄存器的该进程页目录的物理地址。内核还需要读取其他很多项数据，每次读取都重复上述1、2步。 
4． 最终内核完成准备过程后将页目录的物理地址加载入CR3寄存器，然后进入该进程，此时才能进入到该进程的地址空间后才能访问该进程的数据。 
5． 假如进程开始执行后需要获取数据，则要用新的段描述符表、页目录表，全部都要从内存中重新加载一遍。 
6． 以上过程中省略了读取段描述符、权限检查的过程，简化了有可能存在的修改gdtr寄存器的过程、缺页时的处理等步骤，否则真实的过程将更加复杂

确定一个变量的位置有两个步骤，一是编译链接时期由工具链确定的虚拟地址空间的地址，二是运行时操作系统将虚拟地址映射到一个物理地址。CPU执行指令访问虚拟地址又要经过一系列过程。 

编译器经过扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化等六步，生成目标文件。目标文件中涉及其他模块符号的地址都被设置为0，等待链接过程中确定。 
多个目标文件经过链接生成可执行文件。

链接过程分为静态链接和动态链接两种，在链接控制命令中确定。
###进程
TR寄存器指向当前任务的TSS

![TR寄存器](http://my.csdn.net/uploads/201204/30/1335766319_8712.jpg)

### 锁
Q：死锁产生的必要条件？
A: 四个必要条件。

锁包括互斥锁，条件变量，自旋锁和读写锁。
