# Operating System

## 目录
- [大小端](#大小端)
- [TLB](#TLB)
- [文件共享（多个线程打开同一个文件）](#文件共享（多个线程打开同一个文件）)
- [同步](#同步) 
- [进程间通信方式](#进程间通信方式)
- [linux 下 pthread库（POSIX）](#linux 下 pthread库（POSIX）)
- [匿名管道特性](#匿名管道特性)
- [息队列特性（ipcs -q 查看）](#息队列特性（ipcs -q 查看）) 
- [多级寻址](#多级寻址)
- [PCB](#PCB)
---

[操作系统清华向勇陈渝版笔记](https://blog.csdn.net/github_36487770/article/details/60144610)

### 大小端
![](http://img.blog.csdn.net/20170906230027562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg4OTYxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

C++代码验证大端还是小端存储
```
#include <iostream>

using namespace std;
int main()
{
    int nNum = 0x12345678;
    char chData = *(char*)(&nNum);

    if (chData == 0x12)
    {
        cout << "big" << endl;
    }
    else
    {
        cout << "small" << endl;
    }

    system("PAUSE");

    return 0;
}

```
### PCB

为了描述和管理进程的运行，在OS的核心专门定义了一个数据结构----进程控制块（PCB）

其作为进程实体的一部分，记录了OS所需的，用于描述进程当前的情况以及进程运行的消息。

作用：使一个在多道程序环境下不能独立运行的程序成为一个能够独立运行的基本单位，一个能与其他进程并发执行的程序。

1：作为独立运行基本单位的标志。系统是通过PCB感知进程的存在。

2:能实现间断性运行的方式。多到程序运行的情况下程序是走走停停，间断运行的，当程序移交CPU的时候必须保留现场，调用时要恢复现场，PCB中保留了中断程序的现场信息，

3：提供进程调度所需的信息：

4：提供进程调度所需的信息；PCB中提供了进程的状态信息，还有其它信息任如（进程的优先级，进程的等待时间，以及和执行时间）

5：实现与其他进程的同步与信息：进程同步机制是用于实现各进程间的协调运行，采用信号量机制时，要求每个进程都设置相应的同于同步的信号量。在PCB中还具有实现进程通信区域或通信队列指针等。

进程控制块中的信息

1：进程标识符（PID）：用于唯一标识一个进程一个进程通常有两种标识符1：外部与内部标识符。

2：处理机状态：处理机的状态信息，也称为处理机的上下文，当进程切换时，处理机的状态信息必须保存在相应的PCB中，以便在该进程重新执行时从断点处开始。

3：进程调度信息：在OS进行进程调度的时候，必须了解进程的状态以及进程的调度信息。

如（进程的状态，进程的优先级，其他消息（进程调度算法），事件（引起阻塞原因））

4：进程的控制信息：包括1：程序和数据地址，2：进程同步和通信机制，3：资源抢清单4：连接指针。


线程有自己的TCB，thread control block, 只负责这条流程的信息，包括PC程序计数器，SP堆栈，State状态，和寄存器。有不同的控制流，需要不同的寄存器来表示控制流的执行状态，每个线程有独立的这些信息，但共享一个资源。

线程=进程-共享资源 

### TLB
Translation Lookaside Buffer.
![TLB_image](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=d92dd174afd3fd1f2204aa6851274e7a/ac6eddc451da81cb627dc1975566d016082431d4.jpg "TLB")
X86保护模式下的寻址方式：段式逻辑地址—〉线形地址—〉页式地址；
页式地址=页面起始地址+页内偏移地址；
对应于虚拟地址：叫page（页面）；对应于物理地址：叫frame（页框）；
X86体系的系统内存里存放了两级页表，第一级页表称为页目录，第二级称为页表。
TLB和CPU里的一级、二级缓存之间不存在本质的区别，只不过前者缓存页表数据，而后两个缓存实际数据。

### 文件共享（多个线程打开同一个文件）
！[file_share_image](http://blog.chinaunix.net/attachment/201109/18/24585858_13163316796P22.jpg)
函数调用fork后产生的父子进程中，它们共享相同的i或v节点和同一个文件表项。



### 同步
线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。

用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。

内核模式下的方法有：事件，信号量，互斥量。

1. 临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
2. 互斥量:为协调共同对一个共享资源的单独访问而设计的。 
3. 信号量:为控制一个具有有限数量用户资源而设计。 
4. 事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

## [进程间通信方式](http://www.cnblogs.com/lenomirei/p/5636339.html)

（1）管道（pipe）及有名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。

（2）信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。

（3）消息队列（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。

（4）共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。

（5）信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。

（6）套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。


## linux 下 pthread库（POSIX）
```
int pthread_create(pthread_t *tidp, //第一个参数为指向线程标识符的指针。
    const pthread_attr_t *attr,    //第二个参数用来设置线程属性。
    (void*)(*start_rtn)(void*), //第三个参数是线程运行函数的起始地址。
    void *arg    //最后一个参数是运行函数的参数
    );

//线程通过调用pthread_exit函数终止执行
void pthread_exit(void* retval);

//函数pthread_join用来等待一个线程的结束,线程间同步的操作,阻塞函数
int pthread_join(pthread_t thread, void **retval);

```
互斥锁：等价于二元信号量

- pthread_mutex_init初始化一个锁
- pthread_mutex_destory销毁互斥锁
- pthread_mutex_lock原子方式给加锁，如果自身线程对自身加锁的锁再次加锁，则死锁；其余线程加锁则不会死锁，但会阻塞。
- pthread_mutex_trylock非阻塞加锁
- pthread_mutex_unlock原子操作方式来解锁

``` 
pthread_mutex_t mutex;
pthread_mutex_init(&mutex, NULL);
pthread_mutex_lock(&mutex);
pthread_mutex_unlock(&mutex);
``` 

同步步骤：信号量 头文件<semaphore.h>

- sem_init函数用于初始化一个未命名的信号量
- sem_destory函数用于销毁信号量
- sem_wait函数以原子操作的方式将信号量的值减1，如果信号量的值为0，则阻塞。
- sem_trywait上面的非阻塞版本，如果信号量为0，立即返回-1，并设置errno为EAGIN
- sem_post将信号量的值加1


### 匿名管道特性

1. 管道是依赖于文件系统的，创建好管道之后，一定要关闭不使用的读写端
2. 只有父子进程才可以使用管道通信，也就是所谓的有血缘关系的进程进行进程间通信。（匿名管道独有）
3. 管道是基于数据流的，面向字节流！（后面会提到消息队列是面向数据块的，对比来看会好懂一些）
4. 管道只能称之为单向数据通信，连半双工都算不上
5. 同步与互斥问题不需要考虑了，管道已经考虑了
6. 当父子进程退出的时候，管道的生命周期就结束了，也就是说管道的生命周期就是进程
7. 最后的最后，来一个管道最大的缺点，管道是基于文件系统的！所以不管是读还是写，都要求访问磁盘进行I/O操作，I/O的速度你懂得，特别慢，所以不适合做多个client的结构，不然会很慢

### 消息队列特性（ipcs -q 查看）
1. 匿名管道是跟随进程的，消息队列是跟随内核的，也就是说进程结束之后，匿名管道就死了，但是消息队列还会存在（除非显示调用函数销毁）
1. 管道是文件，存放在磁盘上，访问速度慢，消息队列是数据结构，存放在内存，访问速度快
1. 管道是数据流式存取，消息队列是数据块式存取


### 多级寻址



###进程
TR寄存器指向当前任务的TSS

![TR寄存器](http://my.csdn.net/uploads/201204/30/1335766319_8712.jpg)
