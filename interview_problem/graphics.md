# 图形学

- [deffered shading](#deffered shading)
- [shadow map](#shadow map)
- [绘制管线](#绘制管线)
-

--- 
### 绘制管线
[绘制管线](https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/)
![](https://learnopengl-cn.github.io/img/01/04/pipeline.png)
图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。

图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。

图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。

几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。

片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。

在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。
### shadow map
 [shadow map ](https://blog.csdn.net/ronintao/article/details/51649664)是一种常用的实时阴影的生成方法。

	通常用来生成平行光（direction light）的阴影,shadow map的核心就是要生成并利用 shadow depth map.

	我们站在光源的位置，按照光线传播的视角，观察场景，计算场景中的物体距离光源的距离（也就是该视角下的深度），并记录各个位置上的最小值（即距离光源最近的点的位置），从而获得一张 shadow depth map。

	如果某个点，其在光源视角下的 depth 大于 shadow map中对应位置的 depth，则意味着它被某个物体遮挡，因此是在阴影中的；反之则不在阴影之中。所以，对于世界中的某个点 p，我们只要将其转移到 light space ，比较他在light space下的depth，就可以判定它是否是在阴影之中了。
	
	可能会出现锯齿状或者self-shadowing，根本原因就是 shadow depth map 的分辨率不够，因此多个 pixel 会对应 map 上的同一个点。解决的方法很简单，其实只有实际深度大于采样深度的时候才有问题，那么我们在计算实际深度的时候，往灯光方向拉一点，让他减小一点就可以了。

	这个方法得到的阴影是hard shadow，使用shadow filter或PCF产生soft shadow，对于PCF，其核心思路就是，如果是影子内部，则他周围的一圈点肯定也在阴影之中，如果是影子边缘，则他周围就会有些点不在阴影里，且越靠边，这些不在阴影中的邻居越多。所以检测一个点是否是在影子边缘，只要观察他的邻居就可以了。

### deffered shading
 deffered shading是这样一种技术：将光照/渲染计算推迟到第二步进行计算。我们这样做的目的是为了避免多次（超过1次）渲染同一个像素。
	基本思想

	1. 在第一步中，我们渲染场景，但是与通常情况下应用反射模型计算片断颜色不同的是，我们只是简单的将几何信息（位置坐标，法线向量，纹理坐标，反射系数等等）存储在中间缓冲区中，这样的缓冲区我们称之为g-buffer（g是几何geometry的缩写）。

	2. 在第二步，我们从g-buffer中读取信息，应用反射模型，计算出每个像素的最终颜色。
	3. Deferred shading技术的应用使得我们避免了应用反射模型于最终不可见的片断上。例如，考虑这样的像素，它位于两个多边形重叠的区域。通常的片断着色器会读对每个多边形分别计算那个像素一次；然而，两次执行的结果最终只有一个成为该像素的最终颜色（这里基于的一个假设是：混合已被禁用）。这样，其中的一次计算就是无用的。有了Deferred shading技术，反射模型的计算会推迟到所有几何体被处理之后，那时候每个像素位置几何体的可见性也是已知的。这样，对于屏幕上的每个像素，反射模型的计算只会发生一次。
	4. 缺点：不能使用基于硬件实现的多重采样抗锯齿功能，因为渲染过程发生在第二步，所以我们在第二步需要多个样本。但是，在第二步我们只有每一个像素的一个样本。另外，不能使用混合技术。
4. Forward shading就是正常的过程