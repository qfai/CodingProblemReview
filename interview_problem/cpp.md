# C++
## 目录
- [ 4种cast](#cast)
- [c++内存布局](#内存布局)
- [智能指针](#智能指针)
- [extern c](#extern-c)
- [new](#new)
- [c++ 类](c++类)
- [函数隐藏](#函数隐藏)
- [typeid](#typeid)
- [cosnt 四种用法](#cosnt-四种用法)
- [i++](#i++)
- [内存对齐](#内存对齐)
- [迭代器删除元素](#迭代器删除元素)
- [内联函数](#内联函数)
- [简易Q&A](#简易Q&A)
- [static和const区别](#static和const区别)
- [内存段](#内存段)
- [数据库索引的实现](#数据库索引的实现)
- [红黑树](#红黑树)
- [string类](#string类)
- [static和const区别](#static和const区别)
---
1. C++方面的基础和细节问题（sizeof(非常细，其实做过不少题，但还是错了一个)，*（a++）+= (*a++)等这类的问题，reinterpret_cast的详细用法）等吧 
2. 手写String(构造，析构，复制构造，operator=, C_str)和其他的算法； 
### cast
	1. const_cast 用来去除常量性和易变性
	2. static_cast 用来强制类型转换:static_cast不做运行时的类型检查以保证转换的安全性
	3. dynamic_cast 用来在继承体系内向下转换（转型失败时NULL（转型指针时）或者exception（转型reference时）会表现出来）
	4. reinterpret_cast 用来转型函数指针，不具备可移植性 
### 内存布局
 [c++对象内存模型【内存布局】](http://blog.csdn.net/it_yuan/article/details/24651347)
### 智能指针
1. auto_ptr：控制权可以随便转换，但是只有一个在用。
		1. base1.get()：返回当前指针对象；
		2. base1.release()：清空当前智能指针对象
		3. base1.reset() :即把内存删除，且智能指针指向空，但类型不变

2. ![](http://img.blog.csdn.net/20160107100157019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
3. shared_ptr内存添加了一个引用计数
4. weak_ptr更像是shared_ptr的助手：

	1、他不像其余三种，可以通过构造函数直接分配对象内存；他必须通过shared_ptr来共享内存。

	2、没有重载opreator*和->操作符，也就意味着即使分配到对象，他也没法使用该对象

	3、不主动参与引用计数，即，share_ptr释放了，那么weak_ptr所存的对象也释放了。

	4、使用成员函数use_count()可以查看当前引用计数，expired()判断引用计数是否为空。

	5、lock()函数，返回一个shared_ptr智能指针：
5. 左值与右值:左值与右值的根本区别在于是否允许取地址&运算符获得对应的内存地址。

       左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)。需要注意的是，左值是指表达式结束后依然存在的持久对象，而右值是指表达式结束时就不再存在的临时对象。T& 指向的是 lvalue，而 const T& 指向的，却可能是 lvalue 或 rvalue，左值引用&与右值引用&&（右值引用是c++11加上的）。

6. move和forward:


       需要明确的是，move函数可以是用于构造函数，也可以用于赋值函数，但都需要手动显示添加。其实move函数用直白点的话来说就是省去拷贝构造和赋值时中间的临时对象，将资源的内存从一个对象移动到（共享也可以）另一个对象。官话是：c++11 中的 move() 是这样一个函数，它接受一个参数，然后返回一个该参数对应的右值引用。

       std::forward<T>(u) 有两个参数：T 与 u。当T为左值引用类型时，u将被转换为T类型的左值，否则u将被转换为T类型右值。如此定义std::forward是为了在使用右值引用参数的函数模板中解决参数的完美转发问题。

### extern c
  extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。

### [new](https://blog.csdn.net/wudaijun/article/details/9273339)

- new operator：指我们在C++里通常用到的关键字，比如A* a = new A;
- operator new：它是一个操作符，并且可被重载(类似加减乘除的操作符重载)
- placement new: 它也是对operator new的一个重载，它可以实现在ptr所指地址上构建一个对象(通过调用其构造函数)，调用形式：new(p) A();new(p) A()调用placement new之后，还会在p上调用A:A()，这里的p可以是动态分配的内存，也可以是栈中缓冲。placement new的主要作用只是将p放入ecx，并且调用其构造函数。
比如我们写如下代码：
```
A* a = new A；
```
我们知道这里分为三步：1.分配内存，2.调用A()构造对象，3. 返回分配指针。事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，否则调用全局::operator new(size_t )，后者由C++默认提供。因此前面的步骤也就是：

1. 调用operator new (sizeof(A))
2. 调用A:A()
3. 返回指针

#### operator new 的应用
1. operator new重载运用于调试：对operator new的重载还可以添加自定义参数，给operator new添加两个参数:char* file, int line,这两个参数记录new关键字的位置，然后再在new时将文件名和行号传入，这样我们就能在分配内存失败时给出提示：输出文件名和行号。
2. 内存池优化：operator new的另一个大用处就是内存池优化，内存池的一个常见策略就是分配一次性分配一块大的内存作为内存池(buffer或pool)，然后重复利用该内存块，每次分配都从内存池中取出，释放则将内存块放回内存池。在我们客户端调用的是new关键字，我们可以改写operator new函数，让它从内存池中取出(当内存池不够时，再从系统堆中一次性分配一块大的)，至于构造和析构则在取出的内存上进行，然后再重载operator delete，它将内存块放回内存池。关于内存池和operator new在参考文献中有一篇很好的文章。这里就不累述了。
3. stl中的new。
#### 重载delete
delete的使用基本和new一致，包括operator delete的重载方式这些都相似，只不过它的参数是void*，返回值为void。operator delete的自定义参数重载并不能手动调用
```
void* operator new(size_t size, int x)  
{  
    cout<<" x = "<<x<<endl;  
    return malloc(size);      
}  
void operator delete(void* p, int x)  
{  
    cout<<" x = "<<x<<endl;  
    free(p);  
}  
A* p = new(3) A;//ok
delete(3) p;//error C2541: “delete”: 不能删除不是指针的对象

```
事实上以上自定义参数operator delete 只在一种情况下被调用：当new关键字抛出异常时。

可以这样理解，只有在new关键字中，编译器才知道你调用的operator new形式，然后它会调用对应的operator delete。一旦出了new关键字，编译器对于这块内存是如何分配的一无所知，因此它只会调用默认的operator delete，而至于为什么不能主动调用自定义delete(而只能老老实实delete p)，这个就不知道了。

1. set_new_handler
还有一些零散的东西没有介绍到，比如set_new_handler可以在malloc(需要调用set_new_mode(1))或operator new内存分配失败时指定一个入口函数new_handler，这个函数完成自定义处理(继续尝试分配，抛出异常，或终止程序)，如果new_handler返回，那么系统将继续尝试分配内存，如果失败，将继续重复调用它，直到内存分配完毕或new_handler不再返回(抛出异常，终止)
2. new分配数组
new[]和new类似，仍然会优先调用类中重载的operator new[]。另外还要注意的是，在operator new[](size_t size)中传入的并不是sizeof(A)*3。而要在对象数组的大小上加上一个额外数据，用于编译器区分对象数组指针和对象指针以及对象数组大小。在VS2008(32 bit)下这个额外数据占4个字节，一个int大小。operator new[]返回的是0x005b668 而最后new关键字返回给p的是0x005b66c。也就是说p就是数组的起始地址，这样程序看到的内存就是线性的，不包括前面的额外数据。
### [c++ 类](https://www.cnblogs.com/greatverve/p/cpp-class.html)


要使用一个C++类，必要的条件是在编译期能得到这个类的头文件（编译器需要在编译期就知道类的内存布局，以保证可以生成正确的开辟内存的代码），并在链接期可以找到对应的符号的链接地址（比如成员函数、静态数据成员等，obj文件）C++类往往被编译器作为一个编译单元，生成一个obj文件。在最后进行链接的过程中，链接器会把工程中所有的obj链接以生成最终的二进制目标文件。所以链接器在遇到一处对类成员函数（或其它形式的符号引用）时，会在这个类生成的obj文件中找到符号的链接地址。
![](http://p.blog.csdn.net/images/p_blog_csdn_net/BalonFan/Snap2.jpg)
根据C++语言的定义，一个C++类实际上是声明或定义了如下几类内容：

1.声明了一个数据结构，类中的非静态数据成员、代码中看不到但如果有虚函数就会生成的虚表入口地址指针等。
2.声明并定义了一堆函数，它们第一个参数都是一个指向这个数据结构的指针。这些实际上就是类中那些非静态成员函数（包括虚函数），它们虽然在类声明中是写在类的一对大括号内部，但实际上没有任何东西被加到前面第1条中所说的内部数据结构中。实际上，这样的声明只是为这些函数增加了两个属性：函数名标识符的作用域被限制在类中；函数第一个参数是this，被省略不写了。
3.声明并定义了另一堆函数，它们看上去就是一些普通函数，与这个类几乎没有关系。这些实际上就是类中那些静态函数，它们也是一样，不会在第1条中所说的内部数据结构中增加什么东西，只是函数名标识符的作用域被限制在类中。
4.声明并定义了一堆全局变量。这些实际上就是类中那些静态数据成员。
5.声明并定义了一个全局变量，此全局变量是一个函数指针数组，用来保存此类中所有的虚函数的入口地址。当然，这个全局变量生成的前提是这个类有虚函数。

导出一个类，编译器实际上只需要将这个类中的：成员函数、静态函数、静态数据成员当成普通的函数、全局变量导出即可。也就是说，我们实际上有“导出一个类”，而是把这个类中需要被引用的“有定义的实体”的入口地址像普通函数和变量那样正常导出即可。由于里面的纯虚函数VBar没有
定义，所以不会被导出。

### 函数隐藏
1. 不论基类函数是否为virtual，只要有派生类函数与其同名但不同参，该基类函数在派生类中将被隐藏。(别与重载混淆)

2. 基类函数非virtual，有派生类函数与此基类函数同名同参，此时该基类函数在派生类中将被隐藏。(别与覆盖混淆)

隐藏就是“内部作用域”的成员屏蔽同名的"外部作用域“成员，如C局部变量屏蔽同名的全局变量。同样基类和派生类也有各自作用域且基类域（外层）包含派生类域（内层），因此如果派生类没有与基类同名成员（变量或函数），则基类成员在派生类里可见（继承）；如果派生类里有同名成员，则基类成员在派生类不可见（隐藏）。

C++有两种方法可以重新启用被隐藏的函数：

    1. 用using关键字，自定义命名空间一节提到using可将一个作用域中的名字引入另一个作用域中；它的另一个用法是”using Base::fun”，这样派生类中如果定义同名但不同参的函数，基类函数将不会被隐藏，两个函数并存在派生类域中形成新的重载，
    2. 用域限定符::来定位继承自Base却被派生类隐藏的成员，如上例将dr.fun1(1);改为dr.Base::fun1(1);即可，这种方法能调用所有被隐藏的基类成员变量和函数。
### typeid  
1.当typeid操作符的操作数是不带有虚函数的类类型时，typeid操作符会指出操作数的类型，而不是底层对象的类型。


2.如果typeid操作符的操作数是至少包含一个虚拟函数的类类型时，并且该表达式是一个基类的引用，则typeid操作符指出底层对象的派生类类型。

### cosnt 四种用法
1.用const修饰函数参数
	1. 修饰指针，可以防止指针被修改:不能对const指针取地址,不能将const指针转普通指针
	2. 修饰普通类型，说明这个参数不应该被修改:不能取地址。const int a,int b=a; //不用强转也可以编译通过，但还是没能力改a的值  
	3. 修饰引用类型，参数的值不能被修改， 也就失去了引用类型的效果，但传递对象时，可以起到不copy对象的目的。
2. 用const修饰局部或全局变量，功能类似函数参数
3. 用const修饰函数返回值，说明函数的返回类型是const的，功能类似于函数参数
4. 用const修饰函数，说明函数不会修改成员变量的值

#### const 实现

据我所知VC++所有标记上const的指针/引用/变量是不会有什么运行时保护的，只有编译的时候做检查而已。至于const char* x="abcde";为什么VC++有保护，那是因为"abcde"被编译在了一个readonly的memory page上面，跟x声明成const char*是没关系的。而且有些const变量在声明时候的值会被“inline”在各个使用他的地方。这个时候如果你const_cast了之后强行修改，编译器是不会管你的，他高兴inline就inline，C++标准没有对此作出任何限制，大概可以算undefined behavior了吧。

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

我们知道C语言中const表示只读的变量，既然把const看成是变量，那么其在内存中就会有存储他的空间，并且可以通过指针间接的改变该内存空间的值，当通过指针p改变该内存中的值后，再获取i的值的时候，会访问该空间，得到的是被改变后的值。而C++把const看做常量，编译器会使用常数直接替换掉对i的引用，例如cout<<i; 会理解成cout<<10; 并不会去访问i的内存地址去取数据，这里有点像是C语言里的宏#define i 10。因此C++里i会输出10，而*p会输出20.

**C++语言中只是对于内置数据类型做常数替换，而对于像结构体这样的非内置数据类型则不会**。因为结构体类型不是内置数据类型，编译器不知道如何直接替换，因此必须要访问内存去取数据，而访问内存去取数据必然会取到被指针q改变后的值，因此会造成与C++中const int类型完全不一样的处理模式。

- 常量指针：const int *p;p=&i;   p指向的对象是常量，即i应该是一个常量，常量指针的真正含义在于不能通过p来改变所指向对象的值，并不代表不能通过其他途径来改变对象的值。
- 指针常量：int * const p=&i;  指针p中存放的地址不可改变，即p只能初始化，不能改变所指向的对象，对象的值可以通过p来改变。

### i++

```
// 前缀形式：++i
int& int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用
{//函数本身无参，意味着是在自身空间内增加1的
  *this += 1;  // 增加
  return *this;  // 取回值
}

//后缀形式:i++
const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。
{//函数带参，说明有另外的空间开辟
  int oldValue = *this;  // 取回值
  ++(*this);  // 增加
  return oldValue;  // 返回被取回的值
}

```
i++ 最后返回的是一个临时变量，而临时变量是右值。


Q:解释器和编译器的区别？
A: Java, Python和各种脚本语言可以通过解释器生成中间代码，中间代码再生成二进制目标代码；C/C++可以通过编译器直接生成二进制目标代码。由于解释器有中间代码这一层，所以可以做到跨平台。

### [内存对齐](https://blog.csdn.net/chy19911123/article/details/48894579)

> 规则不用看了直接点进去看例子就好

1. 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。

2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。

3. 收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的"最宽基本类型成员"的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。

4. sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。


内存对齐的主要作用是：

1、  平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2、  性能原因：经过内存对齐后，CPU的内存访问速度大大提升。具体原因稍后解释。

###[内联函数](http://www.cnblogs.com/shijingjing07/p/5523224.html)
执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入寄存器中），然后跳回到地址被保存的指令处.内联函数提供了另一种选择。编译器将使用相应的函数代码替换函数调用。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。
```
#define SQUARE(X) X*X
``` 
宏定义时通过文本替换开实现的,宏定义和内联函数存在本质的区别，转换的时候应考虑是否转换后功能是否正常。

如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间占比很小。若代码执行时间很短，则内联函数就可以节省函数调用的时间。
### QT

（1） qt类中的一些继承关系？
    （2） qt的信号与槽机制？
    （3） qt有那些类，控件？


### 迭代器删除元素

（1）对于关联容器（如map，set，multimap，multiset），删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前的iterator即可。
（2）对于序列式容器（如vector，deque，list等），删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。不过erase方法可以返回下一个有效的iterator
```
set<int> valset = { 1,2,3,4,5,6 };  
set<int>::iterator iter;  
for (iter = valset.begin(); iter != valset.end(); )  
{  
     if (3 == *iter)  
          valset.erase(iter++);  
     else  
          ++iter;  
}  
```

1. vector:vector在遍历中进行 erase(pos) ，这个时候iter++的时候会出现bug，会跳过一个字段或者coredump。（要删除的时候直接赋值返回值，但是不能++）
```
vector<int>::iterator iter2;  
for(iter2 = vec.begin(); iter2 != vec.end(); )  
{  
    printf("%d " , *iter2 );  
    //注意这里  
    if( *iter2 == 3 ){  
        iter2 = vec.erase( iter2 );  
    }else{  
        iter2++;  
    }  
}  
```
2. list在遍历中进行 erase(pos) ，这个时候iter++的时候会出现bug，会直接coredump。
```
list<int>::iterator iter2;  
for(iter2 = vec.begin(); iter2 != vec.end(); iter2++)  
{  
    printf("%d " , *iter2 );  
    if( *iter2 == 3 ){  
        vec.remove( *iter2 );  //注意这里,调用remove( const TYPE &val );  
    }  
}  
```
3. map在遍历中进行 erase(pos) ，这个时候iter++的时候会出现bug，会出现未知问题。
```
map<int,int>::iterator iter;  
for(iter = testMap.begin(); iter != testMap.end(); iter++)  
{  
    printf("%d " , iter->second );  
    if( iter->second == 3 )  
    {  
        testMap.erase( iter->first ); //注意这里，是通过key删除  
    }  
}  

```
4. 
### 简易Q&A

Q：必须在构造函数初始化式里进行初始化的数据成员有哪些？

A：
1. 需要初始化的数据成员是对象(继承时调用基类构造函数)
2. 需要初始化const修饰的类成员
3. 需要初始化引用成员数据

其中static属于类并不属于具体的对象，所以 static成员是不允许在类内初始化的。

Q：模版特化的概念，为什么特化？

A： 模板分为类模板与函数模板，特化分为全特化与偏特化。全特化就是限定死模板实现的具体类型，偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。而对于函数模板，却只有全特化，不能偏特化：
```
template<typename T1, typename T2>  
class Test  
{  
public:  
    Test(T1 i,T2 j):a(i),b(j){cout<<"模板类"<<endl;}  
private:  
    T1 a;  
    T2 b;  
};  
  
template<>  
class Test<int , char>  
{  
public:  
    Test(int i, char j):a(i),b(j){cout<<"全特化"<<endl;}  
private:  
    int a;  
    char b;  
};  
  
template <typename T2>  
class Test<char, T2>  
{  
public:  
    Test(char i, T2 j):a(i),b(j){cout<<"偏特化"<<endl;}  
private:  
    char a;  
    T2 b;  
};  
```



Q:如何实现只能动态分配类对象，不能定义类对象？

A:
1. 动态分配类对象：就是使用运算符new来创建一个类的对象，在堆上分配内存。
2. 静态分配类对象：就是A a，由编译器创建类对象，在栈上分配内存。 
动态分配类对象：A *p=A::create()
```
class A  
{  
 protected:  
    A() {}  
    ~A() {}  
 public:  
    static A* create()  
    {  
      return new A();  
    }     
    void destroy()  
    {   
      delete this;  
    }     
};  
```

静态分配:只有使用new运算符，对象才会被建立在堆上。因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有.
```
class A   
{  
  private:  
    void* operator new(size_t t)//函数的第一个参数与返回值都是固定的  
    { }  
    void operator delete(void *ptr)//重载了new，就需要重载delete  
    { }  
 public:  
   A() {}  
   ~A() {}  
}  
```


Q: 为什么模板函数不能是虚函数

A: 当前的编译器都期望在处理类的定义的时候就能确定这个类的虚函数表的大小，如果允许有类的虚成员模板函数，那么就必须要求编译器提前知道程序中所有对该类的该虚成员模板函数的调用，而这是不可行的。 成员函数模板只有被使用时才会被实例化，将其声明为虚函数会使vtable的大小不确定。所以，成员函数模板不能为虚函数。


Q: 模板编译注意事项

A:C++中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道，模板类中使用模板类型的对象的所占用的空间的大小的。只有模板被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。这也就是模板类为什么只是称之为模板，而不是泛型的缘故。所以模板类的实现，脱离具体的使用，是无法单独的编译的；把声明和实现分开的做法也是不可取的，必须把实现全部写在头文件里面。

Q：C++ 类内可以定义引用数据成员吗？

A：可以，必须通过成员函数初始化列表初始化。

Q：C++函数栈空间的最大值 ？
A：默认是1M，不过可以调整。
Q：extern “C” ？
A：C++调用C函数需要extern C，因为C语言没有函数重载。


Q：你提到了锁机制，那么C++的锁你知道几种。
A：锁包括互斥锁，条件变量，自旋锁和读写锁（后两个没答出来）。
### 内存段
一个程序一般分为5段

1. text段:就是放程序代码的,编译时确定,只读,

2. 堆栈段：系统分配
3. data段:存放在编译阶段(而非运行时)就能确定的数据,可读可写

就是通常所说的静态存储区,赋了初值的全局变量和静态变量存放在这个区域,常量也存放在这个区域

4. bss段:定义而没有赋初值的全局变量和静态变量,放在这个区域



.bss是不占用.exe文件空间的，其内容由操作系统初始化（清零）；而.data却需要占用，其内容由程序初始化

### static和const区别
static:
用static修饰的变量，在其所限定的作用域中只会有一分内存

1. 在一个函数内部：说明是一个静态局部变量
	1. 函数中声明一个static局部变量，不分配在堆或者栈上，也分配在.data（不分配在.bss）上

	2. 虽然是局部变量，整个进程生命周期都存在，不被释放。

	3. 虽然一直存在，其余函数不能访问，其余源文件更不能

	4. 会被自动初始化（所以不在.bss）上（普通局部变量不会，普通全局变量会自动初始化）

	5. 更进一步，每次调用这个变量时，其初始值都是上一次调用时修改的结果
2. 在一个文件内部，函数外部：静态全局变量,存放在.data（初始化了）或者.bss（未初始化）内.存放在.data（初始化了）或者.bss（未初始化）内
3. static函数：类似面向对象中private封装，其只能被所定义的源文件调用，不能再其他源文件中调用（即使包含头文件。。。。）

类成员的static（C++）:
1. 所有对象共有数据成员或者成员函数，类的静态成员，在类创建时就存在（不需要对象）。
2. static关键字只能用于类内部的声明，不能用于类外部的定义。
3. static成员函数没有this形参（因为不属于某个对象），可以直接访问static数据成员，不能直接使用非static成员。
4. static成员函数不能声明为const，因为const成员函数真正的含义是不修改该成员函数所属的对象，而static成员函数不属于任何对象。
5. 同上，static成员函数不能声明为虚函数！
6. static不是对象的组成部分，只是类的组成部分

#### 静态全局变量和非静态全局变量的区别
>static 限制了变量的作用域只在该文件里，所以加上static在别的文件中国定义一个相同的static没有问题 
没有static修饰的全局变量，要是在不同文件中定义了相同的变量名，程序会报错


#### extern：外部变量
用extern修饰的变量，可以被其他类所访问，凡是引用了extern所修饰的变量的头文件，那么就可以使用该变量。

1. 但是要注意因为static修饰的不在全局符号表中，所以不用区分变量名
2. extern修饰的在全局符号表里面，所以要区分。

const：一个变量用const修饰，说明该变量不可以被修改

1. static限制了变量的作用域，但是#define没有，如果我们仅仅想在一个文件内部使用一个常量，而不影响其他的文件的宏，如果用define，那么所有导入了该文件的那些文件中要是有一个相同的变量，那么这些变量都会被替换 
2. static 形式的常量定义，可以知道其类型，代码可读性好 
3. const的修饰使得该变量在修改会保存，确保其不会被修改，但是#define却不会，值可能会被修改



### string类
https://www.cnblogs.com/zhizhan/p/4876093.html

sizeof(string)==28(vs) sizeof不是函数，相当于宏，因为编译器知道每个类的大小


- 若干个运算符重载，这里的几个是常见的运算符，可以加深对String的认识和运算符重载的理解。
- 两个常用的函数，包括取字符串长度和取C类型的字符串。
- 两个处理输入输出的运算符重载，为了使用的方便，这里把这两个运算符定义为友元函数。
```
class String
{
public:
	String(const char *str = NULL);	//通用构造函数
	String(const String &str);		//拷贝构造函数
	~String();						//析构函数

	String operator+(const String &str) const;	//重载+
	String& operator=(const String &str);		//重载=
	String& operator+=(const String &str);		//重载+=
	bool operator==(const String &str) const;	//重载==
	char& operator[](int n) const;				//重载[]

	size_t size() const;		//获取长度
	const char* c_str() const;	//获取C字符串

	friend istream& operator>>(istream &is, String &str);//输入
	friend ostream& operator<<(ostream &os, String &str);//输出

private:
	char *data;		//字符串
	size_t length;	//长度
};
```

### 红黑树
https://blog.csdn.net/sun_tttt/article/details/65445754

定义
1. 性质一：节点是红色或者是黑色； 
2. 性质二：根节点是黑色； 
3. 性质三：每个叶节点（NIL或空节点）是黑色；
4.  性质四：每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）；
5.  从根节点到每一个NIL节点的路径中，都包含了相同数量的黑色节点。 

### 数据库索引的实现

https://www.cnblogs.com/coprince/p/5695113.html


### delete

C++告诉我们在回收用 new 分配的单个对象的内存空间的时候用 delete，回收用 new[] 分配的一组对象的内存空间的时候用 delete[]。

关于 new[] 和 delete[]，其中又分为两种情况：(1) 为基本数据类型分配和回收空间；(2) 为自定义类型分配和回收空间。

1. 从运行结果中我们可以看出，delete p1 在回收空间的过程中，只有 p1[0] 这个对象调用了析构函数，其它对象如 p1[1]、p1[2] 等都没有调用自身的析构函数，这就是问题的症结所在。如果用 delete[]，则在回收空间之前所有对象都会首先调用自己的析构函数。
2. **基本类型的对象没有析构函数**，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的；**但是对于类对象数组**，只能用 delete[]。对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间。
3. 所以一个简单的使用原则就是：new 和 delete、new[] 和 delete[] 对应使用。

### 初始化列表
c++11 的初始化列表放宽了。对于聚合类型，初始化列表相当于对其中每个元素分别赋值，对于非聚合类型，需要自定义构造函数，使用初始化列表相当于调用其对应构造函数。此外，初始化列表会防止类型收窄的情况产生。

### 智能指针

1. shared_ptr 使用引用计数的智能指针。
2. unique_ptr 独占的智能指针，不能赋值，只能 ptr=move(aotherptr)。可以指向数组。
3. weak_ptr 弱引用智能指针， 用来监视shared_ptr的，不会增加或减少计数，可以查看shared_ptr的计数和是否存在

注意事项。
1. 不要用一个原始指针初始化多个shared_ptr。会出现析构多次的问题
2. 不要在实参中创建shared_ptr
3. 不要返回this指针的shared_ptr，要通过shared_from_this()返回。此时是通过weak_ptr将所观测的shared_ptr返回，
4. 要避免循环引用，可以将某一个循环引用中改成weak_ptr即可


auto_ptr 不能管理对象数组，是转移拷贝语意。用拷贝构造函数或者赋值函数后，原有指针会被置NULL

### 常量表达式
常量表达式机制是为了：

提供了更多的通用的值不发生变化的表达式

允许用户自定义的类型成为常量表达式

提供了一种保证在编译期完成初始化的方法（可以在编译时期执行某些函数调用）

constexpr修饰的值要有初始值，和const不同的是初始化的值可以一个表达式，但是这个表达式的值必须是在编译期间就能确定值的。

个人的理解就是constexpr扩展了常量的含义，从语法上支持更多的常量定义，对比宏又有更好的类型检测和安全性，更强的约束语法带来更好的代码优化。

constexpr：不光是可以取代模板是某些常量的表达更简洁，其实一个决定性的作用是支持地址类常量。这恰好补上了模板缺失的部分。比如有一个字符串常量"abc"，很自然的可以认为其中的元素也是常量地址，对一个有编译期内容的常量地址取值理论上可以在编译器确定结果，但实际上按旧语法却不能直接拿去做为常量使用而是当作变量。

union带构造函数、支持带用户定义构造函数的类作为其成员，本意是用来支持某种多型变量，比如根据某个标志决定一个这样的union当前是什么类型。滥用则会导致数据错误。

noexcept支持推导，而容器元素在支持右值引用的情况下这类推导是很重要的。右值引用可以减少深拷贝的需求，但是在某些情况下会破坏强异常安全保证。利用noexcept推导来决定一个复杂类型作为容器元素的时候到底适合用移动还是适合用普通的拷贝策略来保证强异常安全。比如一个类型如果不支持无异常的移动（自身或任一基类或者数据成员的移动构造函数不支持noexcept，因此需要用到推导），则这个类型不适合移动而只能使用拷贝实现异常安全

1. 指值不会改变并且在编译过程就能得到计算结果的表达式。 
2. constexpr变量：C++ 11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。若不是，则编译报错。同时，声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。
3.  字面值类型：对声明constexpr时用到的类型被称为字面值类型。算术类型、引用、指针、枚举和一些特殊的类都属于字面值类型，而IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。
4. 尽管指针和引用都能被定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。

2. 函数体内定义的变量一般来说并非存在固定地址中（除了static等修饰，且const也不行，static之前不能加限定词volatile，否则出错），相反，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针，同时能用constexpr引用绑定到这样的变量上。

3. 对于指针而言，constexpr仅对指针有效，与指针所指的对象无关。 
4. constexpr指针既可以指向常量也可以指向一个非常量。 


### 设计模式

工厂模式？优点？
A：优点就是解耦，代码复用，更改功能容易。

### C++如何处理内存泄漏

 1. 监控new的使用（自定义new，记录日志）
 2. 使用工具
 3. 定期检查内存结构，查看是否有大量重复结构的内存（表示有相同的对象被创建）。



### C++ 如何处理程序异常
A：查看对应的报错代码，根据代码定位具体问题。