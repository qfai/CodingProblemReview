# C++
## 目录
- [ 4种cast](#cast)
- [c++内存布局](#内存布局)
- [智能指针](#智能指针)
- [extern c][#extern c]
- [new](#new)
- [c++ 类](c++类)
- [函数隐藏](#函数隐藏)
- [typeid](#typeid)
- [cosnt 四种用法](#cosnt 四种用法)
- [i++](#i++)
- [内存对齐](#内存对齐)
- [迭代器删除元素](#迭代器删除元素)
- [内联函数](#内联函数)
- [简易Q&A](#简易Q&A)
---
1. C++方面的基础和细节问题（sizeof(非常细，其实做过不少题，但还是错了一个)，*（a++）+= (*a++)等这类的问题，reinterpret_cast的详细用法）等吧 
2. 手写String(构造，析构，复制构造，operator=, C_str)和其他的算法； 
### cast
	1. const_cast 用来去除常量性和易变性
	2. static_cast 用来强制类型转换
	3. dynamic_cast 用来在继承体系内向下转换（转型失败时NULL（转型指针时）或者exception（转型reference时）会表现出来）
	4. reinterpret_cast 用来转型函数指针，不具备可移植性 
### 内存布局
 [c++对象内存模型【内存布局】](http://blog.csdn.net/it_yuan/article/details/24651347)
### 智能指针
1. auto_ptr：控制权可以随便转换，但是只有一个在用。
		1. base1.get()：返回当前指针对象；
		2. base1.release()：清空当前智能指针对象
		3. base1.reset() :即把内存删除，且智能指针指向空，但类型不变

2. ![](http://img.blog.csdn.net/20160107100157019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
3. shared_ptr内存添加了一个引用计数
4. weak_ptr更像是shared_ptr的助手：

	1、他不像其余三种，可以通过构造函数直接分配对象内存；他必须通过shared_ptr来共享内存。

	2、没有重载opreator*和->操作符，也就意味着即使分配到对象，他也没法使用该对象

	3、不主动参与引用计数，即，share_ptr释放了，那么weak_ptr所存的对象也释放了。

	4、使用成员函数use_count()可以查看当前引用计数，expired()判断引用计数是否为空。

	5、lock()函数，返回一个shared_ptr智能指针：
5. 左值与右值:左值与右值的根本区别在于是否允许取地址&运算符获得对应的内存地址。

       左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)。需要注意的是，左值是指表达式结束后依然存在的持久对象，而右值是指表达式结束时就不再存在的临时对象。T& 指向的是 lvalue，而 const T& 指向的，却可能是 lvalue 或 rvalue，左值引用&与右值引用&&（右值引用是c++11加上的）。

6. move和forward:


       需要明确的是，move函数可以是用于构造函数，也可以用于赋值函数，但都需要手动显示添加。其实move函数用直白点的话来说就是省去拷贝构造和赋值时中间的临时对象，将资源的内存从一个对象移动到（共享也可以）另一个对象。官话是：c++11 中的 move() 是这样一个函数，它接受一个参数，然后返回一个该参数对应的右值引用。

       std::forward<T>(u) 有两个参数：T 与 u。当T为左值引用类型时，u将被转换为T类型的左值，否则u将被转换为T类型右值。如此定义std::forward是为了在使用右值引用参数的函数模板中解决参数的完美转发问题。

### extern c
  extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。

### [new](https://blog.csdn.net/wudaijun/article/details/9273339)

- new operator：指我们在C++里通常用到的关键字，比如A* a = new A;
- operator new：它是一个操作符，并且可被重载(类似加减乘除的操作符重载)
- placement new: 它也是对operator new的一个重载，它可以实现在ptr所指地址上构建一个对象(通过调用其构造函数)，调用形式：new(p) A();new(p) A()调用placement new之后，还会在p上调用A:A()，这里的p可以是动态分配的内存，也可以是栈中缓冲。placement new的主要作用只是将p放入ecx，并且调用其构造函数。
比如我们写如下代码：
```
A* a = new A；
```
我们知道这里分为三步：1.分配内存，2.调用A()构造对象，3. 返回分配指针。事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，否则调用全局::operator new(size_t )，后者由C++默认提供。因此前面的步骤也就是：

1. 调用operator new (sizeof(A))
2. 调用A:A()
3. 返回指针

#### operator new 的应用
1. operator new重载运用于调试：对operator new的重载还可以添加自定义参数，给operator new添加两个参数:char* file, int line,这两个参数记录new关键字的位置，然后再在new时将文件名和行号传入，这样我们就能在分配内存失败时给出提示：输出文件名和行号。
2. 内存池优化：operator new的另一个大用处就是内存池优化，内存池的一个常见策略就是分配一次性分配一块大的内存作为内存池(buffer或pool)，然后重复利用该内存块，每次分配都从内存池中取出，释放则将内存块放回内存池。在我们客户端调用的是new关键字，我们可以改写operator new函数，让它从内存池中取出(当内存池不够时，再从系统堆中一次性分配一块大的)，至于构造和析构则在取出的内存上进行，然后再重载operator delete，它将内存块放回内存池。关于内存池和operator new在参考文献中有一篇很好的文章。这里就不累述了。
3. stl中的new。
#### 重载delete
delete的使用基本和new一致，包括operator delete的重载方式这些都相似，只不过它的参数是void*，返回值为void。operator delete的自定义参数重载并不能手动调用
```
void* operator new(size_t size, int x)  
{  
    cout<<" x = "<<x<<endl;  
    return malloc(size);      
}  
void operator delete(void* p, int x)  
{  
    cout<<" x = "<<x<<endl;  
    free(p);  
}  
A* p = new(3) A;//ok
delete(3) p;//error C2541: “delete”: 不能删除不是指针的对象

```
事实上以上自定义参数operator delete 只在一种情况下被调用：当new关键字抛出异常时。

可以这样理解，只有在new关键字中，编译器才知道你调用的operator new形式，然后它会调用对应的operator delete。一旦出了new关键字，编译器对于这块内存是如何分配的一无所知，因此它只会调用默认的operator delete，而至于为什么不能主动调用自定义delete(而只能老老实实delete p)，这个就不知道了。

1. set_new_handler
还有一些零散的东西没有介绍到，比如set_new_handler可以在malloc(需要调用set_new_mode(1))或operator new内存分配失败时指定一个入口函数new_handler，这个函数完成自定义处理(继续尝试分配，抛出异常，或终止程序)，如果new_handler返回，那么系统将继续尝试分配内存，如果失败，将继续重复调用它，直到内存分配完毕或new_handler不再返回(抛出异常，终止)
2. new分配数组
new[]和new类似，仍然会优先调用类中重载的operator new[]。另外还要注意的是，在operator new[](size_t size)中传入的并不是sizeof(A)*3。而要在对象数组的大小上加上一个额外数据，用于编译器区分对象数组指针和对象指针以及对象数组大小。在VS2008(32 bit)下这个额外数据占4个字节，一个int大小。operator new[]返回的是0x005b668 而最后new关键字返回给p的是0x005b66c。也就是说p就是数组的起始地址，这样程序看到的内存就是线性的，不包括前面的额外数据。
### [c++ 类](https://www.cnblogs.com/greatverve/p/cpp-class.html)


要使用一个C++类，必要的条件是在编译期能得到这个类的头文件（编译器需要在编译期就知道类的内存布局，以保证可以生成正确的开辟内存的代码），并在链接期可以找到对应的符号的链接地址（比如成员函数、静态数据成员等，obj文件）C++类往往被编译器作为一个编译单元，生成一个obj文件。在最后进行链接的过程中，链接器会把工程中所有的obj链接以生成最终的二进制目标文件。所以链接器在遇到一处对类成员函数（或其它形式的符号引用）时，会在这个类生成的obj文件中找到符号的链接地址。
![](http://p.blog.csdn.net/images/p_blog_csdn_net/BalonFan/Snap2.jpg)
根据C++语言的定义，一个C++类实际上是声明或定义了如下几类内容：

1.声明了一个数据结构，类中的非静态数据成员、代码中看不到但如果有虚函数就会生成的虚表入口地址指针等。
2.声明并定义了一堆函数，它们第一个参数都是一个指向这个数据结构的指针。这些实际上就是类中那些非静态成员函数（包括虚函数），它们虽然在类声明中是写在类的一对大括号内部，但实际上没有任何东西被加到前面第1条中所说的内部数据结构中。实际上，这样的声明只是为这些函数增加了两个属性：函数名标识符的作用域被限制在类中；函数第一个参数是this，被省略不写了。
3.声明并定义了另一堆函数，它们看上去就是一些普通函数，与这个类几乎没有关系。这些实际上就是类中那些静态函数，它们也是一样，不会在第1条中所说的内部数据结构中增加什么东西，只是函数名标识符的作用域被限制在类中。
4.声明并定义了一堆全局变量。这些实际上就是类中那些静态数据成员。
5.声明并定义了一个全局变量，此全局变量是一个函数指针数组，用来保存此类中所有的虚函数的入口地址。当然，这个全局变量生成的前提是这个类有虚函数。

导出一个类，编译器实际上只需要将这个类中的：成员函数、静态函数、静态数据成员当成普通的函数、全局变量导出即可。也就是说，我们实际上有“导出一个类”，而是把这个类中需要被引用的“有定义的实体”的入口地址像普通函数和变量那样正常导出即可。由于里面的纯虚函数VBar没有
定义，所以不会被导出。

### 函数隐藏
1. 不论基类函数是否为virtual，只要有派生类函数与其同名但不同参，该基类函数在派生类中将被隐藏。(别与重载混淆)

2. 基类函数非virtual，有派生类函数与此基类函数同名同参，此时该基类函数在派生类中将被隐藏。(别与覆盖混淆)

隐藏就是“内部作用域”的成员屏蔽同名的"外部作用域“成员，如C局部变量屏蔽同名的全局变量。同样基类和派生类也有各自作用域且基类域（外层）包含派生类域（内层），因此如果派生类没有与基类同名成员（变量或函数），则基类成员在派生类里可见（继承）；如果派生类里有同名成员，则基类成员在派生类不可见（隐藏）。

C++有两种方法可以重新启用被隐藏的函数：

    1. 用using关键字，自定义命名空间一节提到using可将一个作用域中的名字引入另一个作用域中；它的另一个用法是”using Base::fun”，这样派生类中如果定义同名但不同参的函数，基类函数将不会被隐藏，两个函数并存在派生类域中形成新的重载，
    2. 用域限定符::来定位继承自Base却被派生类隐藏的成员，如上例将dr.fun1(1);改为dr.Base::fun1(1);即可，这种方法能调用所有被隐藏的基类成员变量和函数。
### typeid  
1.当typeid操作符的操作数是不带有虚函数的类类型时，typeid操作符会指出操作数的类型，而不是底层对象的类型。


2.如果typeid操作符的操作数是至少包含一个虚拟函数的类类型时，并且该表达式是一个基类的引用，则typeid操作符指出底层对象的派生类类型。

### cosnt 四种用法
1.用const修饰函数参数
	1. 修饰指针，可以防止指针被修改:不能对const指针取地址,不能将const指针转普通指针
	2. 修饰普通类型，说明这个参数不应该被修改:不能取地址。const int a,int b=a; //不用强转也可以编译通过，但还是没能力改a的值  
	3. 修饰引用类型，参数的值不能被修改， 也就失去了引用类型的效果，但传递对象时，可以起到不copy对象的目的。
2. 用const修饰局部或全局变量，功能类似函数参数
3. 用const修饰函数返回值，说明函数的返回类型是const的，功能类似于函数参数
4. 用const修饰函数，说明函数不会修改成员变量的值

#### const 实现

据我所知VC++所有标记上const的指针/引用/变量是不会有什么运行时保护的，只有编译的时候做检查而已。至于const char* x="abcde";为什么VC++有保护，那是因为"abcde"被编译在了一个readonly的memory page上面，跟x声明成const char*是没关系的。而且有些const变量在声明时候的值会被“inline”在各个使用他的地方。这个时候如果你const_cast了之后强行修改，编译器是不会管你的，他高兴inline就inline，C++标准没有对此作出任何限制，大概可以算undefined behavior了吧。

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

我们知道C语言中const表示只读的变量，既然把const看成是变量，那么其在内存中就会有存储他的空间，并且可以通过指针间接的改变该内存空间的值，当通过指针p改变该内存中的值后，再获取i的值的时候，会访问该空间，得到的是被改变后的值。而C++把const看做常量，编译器会使用常数直接替换掉对i的引用，例如cout<<i; 会理解成cout<<10; 并不会去访问i的内存地址去取数据，这里有点像是C语言里的宏#define i 10。因此C++里i会输出10，而*p会输出20.

**C++语言中只是对于内置数据类型做常数替换，而对于像结构体这样的非内置数据类型则不会**。因为结构体类型不是内置数据类型，编译器不知道如何直接替换，因此必须要访问内存去取数据，而访问内存去取数据必然会取到被指针q改变后的值，因此会造成与C++中const int类型完全不一样的处理模式。

- 常量指针：const int *p;p=&i;   p指向的对象是常量，即i应该是一个常量，常量指针的真正含义在于不能通过p来改变所指向对象的值，并不代表不能通过其他途径来改变对象的值。
- 指针常量：int * const p=&i;  指针p中存放的地址不可改变，即p只能初始化，不能改变所指向的对象，对象的值可以通过p来改变。

### i++

```
// 前缀形式：++i
int& int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用
{//函数本身无参，意味着是在自身空间内增加1的
  *this += 1;  // 增加
  return *this;  // 取回值
}

//后缀形式:i++
const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。
{//函数带参，说明有另外的空间开辟
  int oldValue = *this;  // 取回值
  ++(*this);  // 增加
  return oldValue;  // 返回被取回的值
}

```
i++ 最后返回的是一个临时变量，而临时变量是右值。


Q:解释器和编译器的区别？
A: Java, Python和各种脚本语言可以通过解释器生成中间代码，中间代码再生成二进制目标代码；C/C++可以通过编译器直接生成二进制目标代码。由于解释器有中间代码这一层，所以可以做到跨平台。

### [内存对齐](https://blog.csdn.net/chy19911123/article/details/48894579)

> 规则不用看了直接点进去看例子就好

1. 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。

2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。

3. 收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的"最宽基本类型成员"的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。

4. sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。


内存对齐的主要作用是：

1、  平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2、  性能原因：经过内存对齐后，CPU的内存访问速度大大提升。具体原因稍后解释。

###[内联函数](http://www.cnblogs.com/shijingjing07/p/5523224.html)
执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入寄存器中），然后跳回到地址被保存的指令处.内联函数提供了另一种选择。编译器将使用相应的函数代码替换函数调用。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。
```
#define SQUARE(X) X*X
``` 
宏定义时通过文本替换开实现的,宏定义和内联函数存在本质的区别，转换的时候应考虑是否转换后功能是否正常。

如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间占比很小。若代码执行时间很短，则内联函数就可以节省函数调用的时间。
### QT

（1） qt类中的一些继承关系？
    （2） qt的信号与槽机制？
    （3） qt有那些类，控件？


### 迭代器删除元素

（1）对于关联容器（如map，set，multimap，multiset），删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前的iterator即可。
（2）对于序列式容器（如vector，deque，list等），删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。不过erase方法可以返回下一个有效的iterator
```
set<int> valset = { 1,2,3,4,5,6 };  
set<int>::iterator iter;  
for (iter = valset.begin(); iter != valset.end(); )  
{  
     if (3 == *iter)  
          valset.erase(iter++);  
     else  
          ++iter;  
}  
```

1. vector:vector在遍历中进行 erase(pos) ，这个时候iter++的时候会出现bug，会跳过一个字段或者coredump。（要删除的时候直接赋值返回值，但是不能++）
```
vector<int>::iterator iter2;  
for(iter2 = vec.begin(); iter2 != vec.end(); )  
{  
    printf("%d " , *iter2 );  
    //注意这里  
    if( *iter2 == 3 ){  
        iter2 = vec.erase( iter2 );  
    }else{  
        iter2++;  
    }  
}  
```
2. list在遍历中进行 erase(pos) ，这个时候iter++的时候会出现bug，会直接coredump。
```
list<int>::iterator iter2;  
for(iter2 = vec.begin(); iter2 != vec.end(); iter2++)  
{  
    printf("%d " , *iter2 );  
    if( *iter2 == 3 ){  
        vec.remove( *iter2 );  //注意这里,调用remove( const TYPE &val );  
    }  
}  
```
3. map在遍历中进行 erase(pos) ，这个时候iter++的时候会出现bug，会出现未知问题。
```
map<int,int>::iterator iter;  
for(iter = testMap.begin(); iter != testMap.end(); iter++)  
{  
    printf("%d " , iter->second );  
    if( iter->second == 3 )  
    {  
        testMap.erase( iter->first ); //注意这里，是通过key删除  
    }  
}  

```
4. 
### 简易Q&A

Q：必须在构造函数初始化式里进行初始化的数据成员有哪些？

A：
1. 需要初始化的数据成员是对象(继承时调用基类构造函数)
2. 需要初始化const修饰的类成员
3. 需要初始化引用成员数据

其中static属于类并不属于具体的对象，所以 static成员是不允许在类内初始化的。

Q：模版特化的概念，为什么特化？

A： 模板分为类模板与函数模板，特化分为全特化与偏特化。全特化就是限定死模板实现的具体类型，偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。而对于函数模板，却只有全特化，不能偏特化：
```
template<typename T1, typename T2>  
class Test  
{  
public:  
    Test(T1 i,T2 j):a(i),b(j){cout<<"模板类"<<endl;}  
private:  
    T1 a;  
    T2 b;  
};  
  
template<>  
class Test<int , char>  
{  
public:  
    Test(int i, char j):a(i),b(j){cout<<"全特化"<<endl;}  
private:  
    int a;  
    char b;  
};  
  
template <typename T2>  
class Test<char, T2>  
{  
public:  
    Test(char i, T2 j):a(i),b(j){cout<<"偏特化"<<endl;}  
private:  
    char a;  
    T2 b;  
};  
```



Q:如何实现只能动态分配类对象，不能定义类对象？

A:
1. 动态分配类对象：就是使用运算符new来创建一个类的对象，在堆上分配内存。
2. 静态分配类对象：就是A a，由编译器创建类对象，在栈上分配内存。 
动态分配类对象：A *p=A::create()
```
class A  
{  
 protected:  
    A() {}  
    ~A() {}  
 public:  
    static A* create()  
    {  
      return new A();  
    }     
    void destroy()  
    {   
      delete this;  
    }     
};  
```

静态分配:只有使用new运算符，对象才会被建立在堆上。因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有.
```
class A   
{  
  private:  
    void* operator new(size_t t)//函数的第一个参数与返回值都是固定的  
    { }  
    void operator delete(void *ptr)//重载了new，就需要重载delete  
    { }  
 public:  
   A() {}  
   ~A() {}  
}  
```


Q: 为什么模板函数不能是虚函数

A: 当前的编译器都期望在处理类的定义的时候就能确定这个类的虚函数表的大小，如果允许有类的虚成员模板函数，那么就必须要求编译器提前知道程序中所有对该类的该虚成员模板函数的调用，而这是不可行的。 成员函数模板只有被使用时才会被实例化，将其声明为虚函数会使vtable的大小不确定。所以，成员函数模板不能为虚函数。


Q: 模板编译注意事项

A:C++中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道，模板类中使用模板类型的对象的所占用的空间的大小的。只有模板被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。这也就是模板类为什么只是称之为模板，而不是泛型的缘故。所以模板类的实现，脱离具体的使用，是无法单独的编译的；把声明和实现分开的做法也是不可取的，必须把实现全部写在头文件里面。