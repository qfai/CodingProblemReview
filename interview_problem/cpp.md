# C++

1. C++方面的基础和细节问题（sizeof(非常细，其实做过不少题，但还是错了一个)，*（a++）+= (*a++)等这类的问题，reinterpret_cast的详细用法）等吧 
2. 手写String(构造，析构，复制构造，operator=, C_str)和其他的算法； 
3. cast
	1. const_cast 用来去除常量性和易变性
	2. static_cast 用来强制类型转换
	3. dynamic_cast 用来在继承体系内向下转换（转型失败时NULL（转型指针时）或者exception（转型reference时）会表现出来）
	4. reinterpret_cast 用来转型函数指针，不具备可移植性 
4. [c++对象内存模型【内存布局】](http://blog.csdn.net/it_yuan/article/details/24651347)
5. 智能指针
	1. auto_ptr：控制权可以随便转换，但是只有一个在用。
		1. base1.get()：返回当前指针对象；
		2. base1.release()：清空当前智能指针对象
		3. base1.reset() :即把内存删除，且智能指针指向空，但类型不变

	2. ![](http://img.blog.csdn.net/20160107100157019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
6. 左值与右值:

       左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)。需要注意的是，左值是指表达式结束后依然存在的持久对象，而右值是指表达式结束时就不再存在的临时对象。T& 指向的是 lvalue，而 const T& 指向的，却可能是 lvalue 或 rvalue，左值引用&与右值引用&&（右值引用是c++11加上的）。

2. move和forward:


       需要明确的是，move函数可以是用于构造函数，也可以用于赋值函数，但都需要手动显示添加。其实move函数用直白点的话来说就是省去拷贝构造和赋值时中间的临时对象，将资源的内存从一个对象移动到（共享也可以）另一个对象。官话是：c++11 中的 move() 是这样一个函数，它接受一个参数，然后返回一个该参数对应的右值引用。

       std::forward<T>(u) 有两个参数：T 与 u。当T为左值引用类型时，u将被转换为T类型的左值，否则u将被转换为T类型右值。如此定义std::forward是为了在使用右值引用参数的函数模板中解决参数的完美转发问题。
3. shared_ptr内存添加了一个引用计数
4. weak_ptr更像是shared_ptr的助手：

	1、他不像其余三种，可以通过构造函数直接分配对象内存；他必须通过shared_ptr来共享内存。

	2、没有重载opreator*和->操作符，也就意味着即使分配到对象，他也没法使用该对象

	3、不主动参与引用计数，即，share_ptr释放了，那么weak_ptr所存的对象也释放了。

	4、使用成员函数use_count()可以查看当前引用计数，expired()判断引用计数是否为空。

	5、lock()函数，返回一个shared_ptr智能指针：
5.   extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。